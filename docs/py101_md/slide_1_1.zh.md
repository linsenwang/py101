# 第 1 章 基础

## 你将学到什么
*   非常基础的 Python 理论。
*   一些基本构成单元。
*   一些函数。
*   记住它们的名称。
*   了解它们参数的含义。
*   理解和解释输出。

!!! info "编程的类比"
    如果我们将程序比作一座建筑，那么变量就是砖块，语法告诉程序员如何将这些砖块组合起来砌成墙。不同的程序只是将墙壁组合起来的不同方式。

## 1. 变量
编程是将数学思想付诸实践的艺术。在你过去的数学学习中，你一定多次见过抽象的概念。让我们来看一个例子。数学中最基本的抽象莫过于变量的创建。在小学，我们学习计数 1、2、3。然后在中学，我们学习使用符号 `𝑥` 来表示一个通用（泛指、代表性）的数字。因此，当我们看到 `𝑥=1`，`𝑥=2`，或者 `𝑥=100` 时，我们不会对单个字母 `𝑥` 如此通用感到惊讶。

在 Python 中，我们称 `𝑥` 为**名称 (names)**。当我们创建一个变量时，我们希望这个变量代表某些**值 (values)**。Python 为我们所做的是首先创建一块内存来存储变量的值，然后将该值（那块内存）绑定到我们提供的名称上。（请参考我在白板上的图示——此处指课堂讲解）。

### 1.1 变量示例：内存地址

```python
# quick verification
a = 1
print(id(a))
b = a
print(id(b))
# not appearing as an address? format it.
print(f"{id(b):02X}")
```

在上面的代码块中，我们看到了：
1.  `print` 函数：用于显示打印内容。
2.  `id` 函数：用于获取对象在内存中的地址。
3.  f-string 格式化：只需在字符串前加上 "f" 并使用 "{}" 包裹变量。

!!! question "课堂练习 1.1.1：变量赋值与打印"
    1.  创建一个名称-值对来存储一个人的名字 "Alice"。
    2.  打印 Alice 的 "name"。
    3.  将该变量绑定到 "Bob"。
    4.  使用 f-string 打印 "name" 的内容。

### 1.2 名称指向对象 (Names Refer to Objects)

!!! note "核心概念"
    *   “名称指向对象” (Names refer to objects)
    *   “Python 中的一切皆对象” (Everything in Python is an object)

虽然我们还没有正式介绍对象，但我们可以粗略地说，**对象是具有特定结构的内存块**。

对象有何特别之处？
一个对象包含…

!!! question "课堂练习 1.1.1.1：对象的特性"
    1.  你能总结一下对象的一些特性吗？
        提示：我们已经了解到一切皆对象。它们有什么共同点？

对象的内容被称为内存布局 (memory layout)。内存布局告诉我们内存块是如何组织以存储数据的。
可以使用 `sys.getsizeof()` 函数查看对象占用的内存大小：
```python
import sys
a = 1
print(sys.getsizeof(a))
```

## 2. 对象类型 (Object Types)
变量类型是一个庞大的主题。官方文档非常长：[https://docs.python.org/3/library/stdtypes.html](https://docs.python.org/3/library/stdtypes.html)

让我们先看几个例子：
```python
a = 1
b = 2.0
c = 3.14-5j
cond = True
```

!!! question "课堂练习 1.2.1：检查变量类型"
    使用 `type()` 函数查看它们分别是什么类型。

### 2.1 简单类型 — 布尔型 (Boolean)
布尔类型在 Python 中很特殊。让我们来研究一下。
我们将需要一个新函数 `isinstance()`。这个函数帮助我们确定一个变量是否是某个类型的成员。

现在，请尝试以下代码：
```python
a = 1
cond = True # 假设 cond 来自之前的例子
print(isinstance(a, int))
print(isinstance(a, type(a))) # 检查 a 是否是其自身类型的实例
print(isinstance(cond, int)) # 检查布尔型变量是否是整型的实例
print(cond + 1) # 布尔型可以参与数学运算
```

!!! note "布尔型与整型"
    在 Python 中，布尔值 `True` 在数值运算中表现为 `1`，而 `False` 表现为 `0`。因此，`isinstance(True, int)` 和 `isinstance(False, int)` 都会返回 `True`。

!!! question "课堂练习 1.2.1.1：探索布尔型和 `isinstance`"
    1.  如果 Python 中的 `True` 也是 `1`，那么 `False` 呢？请验证一下。
    2.  尝试对其他类型使用 `isinstance` 函数。你发现了什么有趣的事情吗？
    3.  在网上搜索 `isinstance` 函数的文档并阅读。

### 2.2 复杂类型 (Complex Types)
前面所有的例子都是单个变量的类型。在 Python 中，我们可以将多个变量组合在一起并创建新的类型。
例如，在高中，你学过 1 是一个数字，2 是一个数字，而 {1, 2} 是一个集合。
在 Python 语言中，由多个变量组成的类型包括**序列 (sequences)**、**映射 (mappings)**、**字符串 (strings)** 等。

#### 2.2.1 序列 — 列表 (list) 与元组 (tuple)
`list` 和 `tuple` 是最常遇到的序列类型。它们通过枚举创建。
```python
l = [1, 2, 3]
t = (1, 2, 3)
```

!!! question "课堂练习 1.2.2.1：列表操作"
    1.  尝试打印一个列表。
    2.  尝试打印列表中的一个元素（例如，第一个或最后一个）。
    3.  创建一个包含从 1 到 100 的 100 个数字的列表。

!!! question "课堂练习 1.2.2.2：元组操作"
    1.  尝试打印一个元组。
    2.  尝试打印元组中的一个元素。
    3.  创建一个包含从 1 到 100 的 100 个数字的元组。

#### 2.2.2 列表和元组的函数与方法
列表和元组有它们自己专门设计的功能。这些“函数”仅适用于特定的列表或元组，被称为**方法 (methods)**，以区别于普通函数。

!!! warning "注意：方法可能修改调用者"
    许多列表方法会**直接修改调用者本身的值**（例如 `append`, `extend`, `pop`）。元组是不可变的，所以它们的方法不会修改元组自身。

一些常见的列表方法：
*   `append()`: 在列表末尾添加单个元素。
*   `extend()`: 用另一个可迭代对象的元素扩展列表。
*   `pop()`: 移除并返回列表中指定位置的元素（默认为最后一个）。
*   `+` 运算符：用于连接列表（或元组），创建一个新的序列。

你已经知道如何从列表和元组中获取一个元素。现在让我们尝试设置列表或元组中元素的值。

!!! question "课堂练习 1.2.2.3：修改序列元素与内存分析"
    1.  使用你刚刚创建的 `l` 和 `t`。
        1.  将 `l` 的第二个元素（索引为1）设置为 -1。打印 `l`。
        2.  尝试将 `t` 的第二个元素（索引为1）设置为 -1。观察会发生什么。
    2.  分析这些更改（或尝试更改）对内存的影响。可以使用 `id()` 函数观察列表 `l` 在修改前后地址是否发生变化。

## 2.2.3 列表与元组的相似性与比较

!!! question "练习：元组操作回顾"
    1.  请尝试打印出你创建的元组中的任意一个元素。
    2.  创建一个新的元组，其中包含从 1 到 100 的所有整数。

### 列表与元组的特有“方法” (Methods)

列表 (list) 和元组 (tuple) 都拥有一些专门为它们设计的内置功能。这些功能与特定的列表或元组实例紧密相关，我们称之为“方法”(Methods)，以区别于可以独立调用的普通函数 (Functions)。

!!! note "关键概念：方法 (Methods)"
    方法是与对象关联的函数，通常直接在对象上调用（例如 `my_list.append(item)`）。它们可以访问和修改对象内部的数据。

!!! warning "重要提示"
    许多列表的方法会直接修改调用该方法的列表本身的值（原地修改），而元组由于其不可变性，没有会修改自身的方法。

常见的列表方法包括：

*   `append()`: 在列表末尾添加单个元素。
*   `extend()`: 在列表末尾追加另一个可迭代对象中的所有元素。
*   `pop()`: 移除并返回列表中指定索引的元素（默认为最后一个）。

`+` 运算符对于列表和元组都可以用于连接操作，但其行为细节有所不同（特别是对于列表，通常会创建一个新列表，而 `extend` 是原地修改）。

### 修改序列中的元素

我们已经学习了如何通过索引访问列表和元组中的单个元素。现在，让我们探讨如何（以及是否能够）修改它们中的元素。

!!! question "课堂练习 1.2.2.3：修改元素与内存分析"
    假设你已经创建了一个列表 `l` 和一个元组 `t` (例如 `l = [10, 20, 30]` 和 `t = (10, 20, 30)`):
    1.  尝试将列表 `l` 的第二个元素（索引为 1）修改为 `-1`。
    2.  尝试将元组 `t` 的第二个元素（索引为 1）修改为 `-1`。
    3.  思考并分析上述操作成功或失败的原因，以及它们在内存层面可能发生的变化（例如，对象 `id` 是否改变，为什么）。

### 列表与元组的相似性与比较

尽管列表和元组都是序列类型，但它们在行为和用途上存在关键差异。

#### 1. 可变性 (Mutability)

*   **列表 (list) 是可变的 (Mutable)**：创建后，可以修改其内容（添加、删除或更改元素）。
    ```python
    l = [1, 2, 3]
    print(f"Original list: {l}, id: {id(l)}")

    l[0] = 100  # 修改元素
    print(f"After l[0]=100: {l}, id: {id(l)}") # 内容改变，id 通常不变

    del l[1]    # 删除元素
    print(f"After del l[1]: {l}, id: {id(l)}")   # 内容改变，id 通常不变
    ```

*   **元组 (tuple) 是不可变的 (Immutable)**：一旦创建，其内容就不能更改。
    ```python
    t = (4, 5, 6)
    print(f"Original tuple: {t}, id: {id(t)}")

    # 下面这些操作会引发 TypeError，因为元组不支持项目赋值或删除
    # t[0] = 100  # 试图修改元素 -> TypeError
    # del t[1]    # 试图删除元素 -> TypeError
    ```

#### 2. 可用方法

由于可变性的差异，列表拥有更多的方法来修改自身，而元组则没有这些方法。

*   **列表的修改方法示例**：
    ```python
    l = [1, 2, 3]
    l.append(4)      # l 变为 [1, 2, 3, 4]
    l.reverse()      # l 变为 [4, 3, 2, 1] (原地反转)
    l.extend([5, 6]) # l 变为 [4, 3, 2, 1, 5, 6]
    item = l.pop(0)  # item 为 4, l 变为 [3, 2, 1, 5, 6]
    print(f"Modified list: {l}")
    ```
*   **元组没有修改自身的方法**：
    ```python
    t = (1, 2, 3)
    # t.append(4)  # 会引发 AttributeError
    # t.reverse()  # 会引发 AttributeError
    # t.extend((5,))# 会引发 AttributeError
    # t.pop()      # 会引发 AttributeError
    ```

#### 3. `+=` 操作符的行为

*   对于**列表**，`+=` 通常执行原地扩展 (in-place extension)，列表对象的 `id` 一般保持不变。
    ```python
    l = [1, 2, 3]
    print(f"ID of l before +=: {id(l)}")
    l += [6, 7] # 等价于 l.extend([6, 7])
    print(f"l after +=: {l}")
    print(f"ID of l after +=: {id(l)}") # id 通常不变
    ```
*   对于**元组**，由于其不可变性，`+=` 操作实际上是创建一个新的元组（包含原始元组和要添加的元组的元素），并将变量名重新绑定到这个新元组上。因此，元组的 `id` 会改变。
    ```python
    t = (1, 2, 3)
    print(f"ID of t before +=: {id(t)}")
    t += (8, 9) # 注意 (8,) 用于创建单元素元组
    print(f"t after +=: {t}")
    print(f"ID of t after +=: {id(t)}") # id 会改变
    ```

#### 4. 共同的序列操作

作为序列类型，列表和元组支持许多相同的操作：

```python
l = [1, "Python", 3.0]
t = (True, 42, "AI")

# 索引访问
print(l[1])  # 输出: Python
print(t[2])  # 输出: AI

# 成员检查 (in)
print(1 in l)         # 输出: True
print("AI" not in t)  # 输出: False (因为 "AI" in t 是 True)

# 列表元素可以被修改
l[1] = "List Element"
print(l) # 输出: [1, 'List Element', 3.0]

# 元组元素不可被修改 (以下操作会报错)
# t[2] = "Tuple Element" # 会引发 TypeError
```
!!! info "回顾：序列类型"
    列表和元组都属于 Python 中的“序列类型”(Sequence Types)，这意味着它们是有序的元素集合，支持索引、切片、成员检查等操作。

## 切片 (Slices)

我们已经熟悉了如何通过单个索引从序列中提取一个元素。切片 (Slicing) 则是一种更为强大的技术，允许我们从序列中一次性提取出一段子序列（多个元素）。

切片的通用语法格式为：`sequence[start:stop:step]`

*   `start`: 切片开始的索引（包含该位置的元素）。如果省略，默认为序列的第一个元素 (索引 0)。
*   `stop`: 切片结束的索引（**不包含**该位置的元素）。如果省略，默认为序列的最后一个元素的下一个位置 (即取到序列末尾)。
*   `step`: 步长，表示每隔多少个元素选取一个。如果省略，默认为 1 (即连续选取)。步长也可以是负数，表示从右向左反向提取。

所有这三个参数 (`start`, `stop`, `step`) 都是可选的。

### 切片对象 (Slice objects)

除了直接在方括号 `[]` 中使用 `start:stop:step` 语法外，Python 还允许我们创建一个“切片对象”。这在需要将切片逻辑作为参数传递给函数，或者在多处复用相同的切片规则时非常有用。

可以使用内置的 `slice()` 函数/类型来创建切片对象：
```python
# 创建一个切片对象，表示从索引1开始，到索引10结束（不包括10），步长为2
s = slice(1, 10, 2)

my_list = list(range(20)) # [0, 1, 2, ..., 19]
print(my_list[s])         # 输出: [1, 3, 5, 7, 9]

# 这等价于直接使用切片语法:
print(my_list[1:10:2])    # 输出: [1, 3, 5, 7, 9]
```
当在方括号 `[]` 中使用已创建的切片对象时，不需要额外的括号。

!!! question "课堂练习 1.2.2.4：类型思考"
    1.  `slice` 是一个函数吗？或者它更应该被称为什么？
    2.  对于一个列表实例 `l` (例如 `l = [1, 2, 3]`)，`l` 是一个函数吗？它是什么？

!!! question "课堂练习 1.2.2.5：识别有效的切片语法"
    判断以下表达式是否可以用作 Python 序列的有效切片（在方括号 `[]` 内或作为 `slice()` 的参数）？如果有效，它们的含义是什么？
    1.  `1:2:1`
    2.  `2:4:7`
    3.  `9:1:-1`
    4.  `a:b:c` (假设 `a`, `b`, `c` 是已定义的整数变量或 `None`)
    5.  `1.5:2.3:3.14` (思考：切片的索引和步长通常是什么类型？)
    6.  `a:2:3` (假设 `a` 是已定义的整数变量或 `None`)
    7.  `6:7`
    8.  `:-5:-1`
    9.  `::-1`

## 其他序列类型：数组 (array) 与双端队列 (deque)

除了我们重点讨论的列表 (list) 和元组 (tuple)，Python 的标准库中还提供了其他有用的序列类型。这里简要介绍两种：

*   **`array.array` (数组)**:
    *   由 `array` 模块提供。与列表类似，`array` 也是一种有序的可变序列。
    *   **主要区别**：`array` 要求其所有元素都必须是**相同的数据类型**（例如，所有元素都是整数，或所有元素都是浮点数）。这种类型限制在创建数组时指定。
    *   **优点**：由于类型统一，`array` 在存储大量同类型数值数据时通常比列表更节省内存，并且在某些底层操作上可能更高效（因为它依赖于C语言数组的紧凑存储和偏移量计算）。
    *   **使用**：需要先 `import array`。
        ```python
        import array

        # 创建一个整数数组 ('i' 代表有符号整数类型)
        numbers = array.array('i', [10, 20, 30, 40, 50])
        print(numbers)
        print(numbers[1]) # 输出: 20

        # numbers.append(3.14) # 这会引发 TypeError，因为数组类型是 'i' (整数)
        ```

*   **`collections.deque` (双端队列)**:
    *   `deque` (发音通常是 "deck"，是 "double-ended queue" 的缩写) 位于 `collections` 模块。
    *   它是一种经过优化的序列，特别擅长在**序列的两端**进行快速的添加 (append) 和弹出 (pop) 操作。
    *   对于列表，在开头插入或删除元素 (如 `my_list.insert(0, x)` 或 `my_list.pop(0)`) 的时间复杂度是 O(N)，因为需要移动后续所有元素。而 `deque` 的 `appendleft()` 和 `popleft()` 操作的时间复杂度是 O(1)。
    *   `deque` 非常适用于实现队列 (FIFO) 和栈 (LIFO，尽管列表的 `append`/`pop` 已经很高效) 以及其他需要高效两端操作的场景。
    *   更多信息和方法，请查阅 Python 官方文档：[collections.deque](https://docs.python.org/3/library/collections.html#collections.deque)

!!! info "学习方法提示"
    Python 及其标准库包含了非常丰富的功能和数据结构。在课程中，我们无法涵盖所有细节。更重要的是掌握学习和探索新知识的方法——例如，学会阅读官方文档、进行实验性编码、以及利用搜索引擎查找特定问题的解决方案。

## 简要回顾 (Review)

*   **Python 变量**: 在 Python 中，变量更准确地说是“名称”或“标签”，它们指向内存中的对象。
*   **对象 (Objects)**: Python 中的一切皆对象。每个对象都具有三个基本特征：
    1.  **`id` (标识)**: 对象在内存中的唯一身份标识（通常是其内存地址）。可以通过 `id()` 函数查看。
    2.  **`type` (类型)**: 对象的类别，决定了该对象可以存储什么样的数据，以及可以对其执行哪些操作。例如 `int`, `float`, `str`, `list`, `tuple`。可以通过 `type()` 函数查看。
    3.  **`value` (值)**: 对象所存储的具体数据。
*   **基本数据类型**: 我们已经接触了一些基本数据类型，包括：
    *   布尔型 (Boolean): `True`, `False`
    *   数字类型 (Numeric): `int`, `float`, `complex`
    *   序列类型 (Sequences): `list`, `tuple`, `str`, `range`, `bytes`, `bytearray` (我们重点学习了前三种)
    *   映射类型 (Mapping): `dict` (后续会学习)
    *   集合类型 (Set Types): `set`, `frozenset` (后续会学习)

---
*原始讲义部分内容参考自: `https://miscrave.com/articles/your-name-flavors-youth/`*
