# 第1章 基础知识

## 可迭代对象 (Iterables)

通俗地说，我们可以将“可迭代对象”（Iterables）看作一种特殊的“类型”。但更准确地说，可迭代对象指的是具有某些共同特性的一类对象。

这些共同特性主要体现在以下几个方面：

1.  **可用于 `for` 循环**：
    所有可迭代对象都可以被传递给 `for` 循环。这与它的名字相呼应：**能够被迭代 (ABLE to be ITERated)**。
    ```python
    for i in an_iterable_object:
        # 执行某些操作
        pass
    ```

2.  **可作为 `iter()` 函数的参数**：
    如果我们将 `iter` 视为一个动词（它在 Python 中实际上是一个内置函数），那么只有可迭代对象才能作为 `iter()` 函数的参数。
    那么，我们如何知道一个对象能否传递给 `iter()` 函数呢？这说明可迭代对象必然有其特殊之处，使其能够成为 `iter()` 函数的参数。

    ```python
    a = [1, 2, 3]  # 列表是可迭代的
    b = 1          # 整数不是可迭代的

    iter(a)  # 正确执行，返回一个迭代器
    # iter(b)  # 会产生 TypeError，因为整数不可迭代
    ```

    !!! note "提示"
        尝试在 Python解释器中执行 `iter(b)` 会得到 `TypeError: 'int' object is not iterable`。

3.  **内置 `__iter__` 方法**：
    使可迭代对象之所以特殊的核心在于它们都实现了一个名为 `__iter__` 的特殊方法（也称为“魔术方法”或“双下划线方法”）。
    我们知道 Python 中的一切皆对象，而对象可以非常复杂，它们能包含各种信息。例如，我们可以使用 `dir()` 函数查看一个列表对象所包含的属性和方法。

    ```python
    a = [1, 2, 3]
    print(dir(a))
    ```
    你会发现输出中包含 `__iter__`。

    可迭代对象的决定性属性就是它们包含一个名为 `__iter__` 的方法。因此，每当我们请求 Python 执行 `iter(a)` 时，Python 实际上会“偷偷地”调用 `a.__iter__()`。这只有在该对象拥有 `__iter__` 方法时才能成功。

4.  **`for` 循环与 `__getitem__` 方法 (补充)**：
    回到 `for` 循环，有时我们也可以将并非严格意义上的可迭代对象（即没有 `__iter__` 方法）传递给 `for` 循环。在这种情况下，该对象必须包含 `__getitem__` 方法，并且通常与一个整数索引一起工作，直到引发 `IndexError`。这是 Python 为了向后兼容早期版本序列类型而提供的一种机制。

    !!! info "背景知识"
        在 `__iter__` 方法被广泛采用之前，`for` 循环主要依赖 `__getitem__` 来迭代序列。现代 Python 更倾向于使用 `__iter__` 协议。

## 可迭代对象与迭代器 (Iterables and Iterators)

迭代器（Iterators）是可迭代对象的一个子集。这意味着：

*   **迭代器本身也是可迭代的**：因此，迭代器也必须拥有 `__iter__` 方法。通常，迭代器的 `__iter__` 方法会返回它自身 (`self`)。
*   **迭代器独有的 `__next__` 方法**：为了与普通的可迭代对象区分开，迭代器还必须包含一个 `__next__` 方法。这个方法是迭代器向前推进并逐个返回值（或在没有更多元素时引发 `StopIteration` 异常）的关键。

!!! note "关键概念：迭代器协议"
    一个对象如果同时实现了 `__iter__()` 方法和 `__next__()` 方法，那么它就是一个迭代器。
    *   `__iter__()`: 返回迭代器对象自身。
    *   `__next__()`: 返回容器中的下一个值。如果容器中没有更多元素了，则应引发 `StopIteration` 异常。

## 为什么需要可迭代对象和迭代器？

*   **可迭代对象无处不在**：
    我们通常不需要自己从头创建很多可迭代对象。Python 内置了许多有用的可迭代对象（如列表、元组、字典、集合、字符串、文件对象等），我们可以直接使用它们。
    可迭代对象的主要用途之一是通过其 `__iter__` 方法（或等效地，使用 `iter()` 内置函数）将其转换为一个迭代器。

*   **迭代器的惰性计算（Lazy Evaluation）**：
    我们需要迭代器的核心原因是，我们不希望 Python 立即完成所有的计算或加载所有的数据。我们希望它仅在我们明确指示它这样做时，才执行必要的操作（即获取下一个元素）。这种“按需获取”的特性也被称为**惰性计算**或**延迟求值**。

    这带来了几个好处：
    *   **内存效率**：对于非常大的数据集（甚至是无限序列），一次性加载到内存中是不现实的。迭代器允许我们逐个处理元素，从而显著减少内存消耗。
    *   **性能提升**：如果只需要处理序列的前几个元素，迭代器可以避免处理整个序列的开销。
    *   **处理无限序列**：迭代器可以用来表示无限的数据流（例如，一个生成无限多个斐波那契数的函数）。

!!! quote "见解：迭代的本质"
    可迭代对象是“可以从中获取迭代器”的对象。
    迭代器是“可以逐个提供元素”的对象。
    `for` 循环的本质就是先从可迭代对象获取迭代器，然后不断调用迭代器的 `__next__` 方法来获取元素，直到捕获到 `StopIteration` 异常为止。
